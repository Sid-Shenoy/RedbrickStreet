1) Zombie streaming + AI (`spawnZombies.ts`)

1.1) Intent

1.1.1) Preload the zombie model once at boot.
1.1.2) Plan a fixed total number of zombie spawns, but instantiate zombie meshes lazily per-house,
       when that house's interior is loaded/streamed in.
1.1.3) Provide lightweight zombie AI:
1.1.3.1) Zombies are idle (no animation) when far from the player.
1.1.3.2) Zombies walk toward the player when within a follow distance threshold.
1.1.3.3) Zombies attack when within an attack distance threshold.
1.1.3.4) Zombies can pass through walls and do not use collision-based movement.
1.1.3.5) Zombies cannot climb stairs (they remain on the first-floor height).
1.1.3.6) While attacking, zombies damage the player via a callback provided by the caller.

1.2) Constants (hard)

1.2.1) `ZOMBIE_COUNT` is a constant and defaults to 25.
1.2.2) `MIN_ZOMBIE_SPAWN_DIST_M` is a constant and defaults to 30.
1.2.3) `ZOMBIE_AI_FOLLOW_DIST_M` is a constant and defaults to 30.
1.2.4) `ZOMBIE_AI_ATTACK_DIST_M` is a constant and defaults to 1.
1.2.5) `ZOMBIE_AI_HIT_DAMAGE` is a constant and defaults to 8.
1.2.6) `ZOMBIE_AI_HIT_COOLDOWN_S` is a constant and defaults to 0.9.
1.2.7) `ZOMBIE_MAX_HEALTH` is a constant and defaults to 100.

1.3) Preloading (hard)

1.3.1) Export: `preloadZombieAssets(scene) -> Promise<AssetContainer>`
1.3.2) Must load zombie model:
1.3.2.1) base path: `assets/models/`
1.3.2.2) file: `zombie.glb`

1.4) Streaming spawner API (hard)

1.4.1) Export:
       `createZombieHouseStreamer(scene, houses, playerStartXZ, zombieAssets, getPlayerXZ, onPlayerDamaged?) -> ZombieHouseStreamer`
1.4.2) `houses` must be `HouseWithModel[]`.
1.4.3) `playerStartXZ` is the player's XZ at game start and is used ONLY for the minimum spawn distance rule (1.6.3).
1.4.4) `getPlayerXZ` must be a callback returning the player's current world XZ:
1.4.4.1) `getPlayerXZ() -> { x: number; z: number }`
1.4.5) `onPlayerDamaged` (optional) must be a callback:
1.4.5.1) `onPlayerDamaged(damage: number) -> void`
1.4.5.2) It must be invoked according to the damage rules in 1.7.6.
1.4.6) `ZombieHouseStreamer` must provide:
1.4.6.1) `ensureHouse(houseNumber: number) -> void`
1.4.6.2) `dispose() -> void`
1.4.6.3) `isZombieHitbox(mesh: AbstractMesh) -> boolean`
1.4.6.4) `damageZombieHitbox(mesh: AbstractMesh, damage: number) -> boolean`
1.4.6.5) `getZombieCounts() -> { alive: number; total: number }`
1.4.6.5.1) `total` must be the initial total zombies planned (i.e., `ZOMBIE_COUNT`)
1.4.6.5.2) `alive` must be the number of remaining (not yet dead) zombies out of `total`

Example usage:
```
const zombieAssets = await preloadZombieAssets(scene);

const streamer = createZombieHouseStreamer(
  scene,
  housesWithModel, {
    x: camera.position.x,
    z: camera.position.z
  },
  zombieAssets,
  () => ({
    x: camera.position.x,
    z: camera.position.z
  }),
  (damage) => {
    // decrease player health here
  }
);
// later, when an interior loads:
streamer.ensureHouse(12);
```

1.5) When `ensureHouse` is called (hard)

1.5.1) It must instantiate all zombies assigned to that `houseNumber` exactly once.
1.5.2) Calling `ensureHouse` multiple times for the same house must have no effect after the first call.
1.5.3) Zombies spawned for a house must be placed using first-floor regions only:
1.5.3.1) Use `house.model.firstFloor.regions`.
1.5.3.2) Do NOT use second-floor regions.
1.5.3.3) Exclude the first-floor `stairs` region (zombies cannot climb stairs).
1.5.3.4) Exclude any region with `surface === "void"`.

1.6) Spawn placement rules (hard)

1.6.1) Total zombies planned across the street must equal `ZOMBIE_COUNT`.
1.6.2) Spawn positions must be chosen randomly from valid first-floor regions, weighted by region area.
1.6.3) No zombie may spawn within `MIN_ZOMBIE_SPAWN_DIST_M` meters (XZ distance) of `playerStartXZ`.
1.6.4) Spawn height is `FIRST_FLOOR_Y`.
1.6.5) Zombie model path is `assets/models/zombie.glb`.

1.7) AI behavior rules (hard)

1.7.1) Distance metric:
1.7.1.1) All AI distance checks must use XZ distance in world space (ignore Y).
1.7.2) Idle state (performance rule):
1.7.2.1) If a zombie's XZ distance to the player is > `ZOMBIE_AI_FOLLOW_DIST_M`,
         the zombie must not be animated (no walk/attack animation playing).
1.7.2.2) While idle, the zombie must not move toward the player.
1.7.3) Walk/chase state:
1.7.3.1) If a zombie's XZ distance to the player is <= `ZOMBIE_AI_FOLLOW_DIST_M` and > `ZOMBIE_AI_ATTACK_DIST_M`,
         the zombie must play a walking/jogging animation and move toward the player.
1.7.4) Attack state:
1.7.4.1) If a zombie's XZ distance to the player is <= `ZOMBIE_AI_ATTACK_DIST_M`,
         the zombie must play an attack animation.
1.7.4.2) While attacking, the zombie must not move toward the player.
1.7.5) Walls and stairs:
1.7.5.1) Zombies can pass through walls: movement must NOT use collision-based movement.
1.7.5.2) Zombies cannot climb stairs: zombie world Y must be clamped to `FIRST_FLOOR_Y` during AI updates.
1.7.6) Damage while attacking (hard)
1.7.6.1) If `onPlayerDamaged` was provided to `createZombieHouseStreamer`, it must be invoked only while attacking.
1.7.6.2) Each attacking zombie must invoke `onPlayerDamaged(ZOMBIE_AI_HIT_DAMAGE)` at most once per
         `ZOMBIE_AI_HIT_COOLDOWN_S` seconds while the player remains within attack range.

1.8) Mesh flags (hard)

1.8.1) Collisions must be disabled for all zombie meshes:
1.8.1.1) `checkCollisions = false`
1.8.1.2) `isPickable = false`

1.9) Failure behavior

1.9.1) If planning cannot place all `ZOMBIE_COUNT` zombies while respecting min distance,
       `createZombieHouseStreamer` must throw an Error.

1.10) Zombie health + being shot

1.10.1) Each zombie must start with `ZOMBIE_MAX_HEALTH` health.
1.10.2) A zombie can be damaged by the player via `damageZombieHitbox(mesh, damage)`.
1.10.2.1) If `mesh` is not a zombie hitbox, the function must return false and do nothing.
1.10.2.2) If the zombie is already dead, the function must return false and do nothing.
1.10.2.3) Otherwise, the function must return true and apply damage.

1.10.3) Hit reaction animation
1.10.3.1) When a zombie takes damage but remains alive, the zombie must play the "Reel back" animation.
1.10.3.2) While this hit reaction is playing, zombie AI must be paused (no movement, no attacks).

1.10.4) Death animation
1.10.4.1) When a zombie's health reaches 0, the zombie must play the "Collapse and die" animation.
1.10.4.2) After death, the zombie must no longer move, attack, or damage the player.
1.10.4.3) After death, the zombie must no longer be shootable (its hitbox must not be pickable/active).

1.10.5) Hitboxes and occlusion
1.10.5.1) Each zombie must have a simple primitive hitbox (e.g. a cylinder or box) that is pickable.
1.10.5.2) Shooting may ignore walls/objects between the player and the zombie (no occlusion test required).

1.11) Zombie sound effects (hard)

1.11.1) Zombies must produce the following sound effects (all under `assets/audio/sfx/zombie/`):
1.11.1.1) `walk.mp3`: While a zombie is walking toward the player from nearby.
1.11.1.2) `attack.mp3`: When a zombie attacks (i.e., when it applies damage to the player).
1.11.1.3) `gethit.mp3`: When a zombie is shot but survives.
1.11.1.4) `death.mp3`: When a zombie dies.

1.11.2) Distance-based volume (realism)
1.11.2.1) All zombie SFX volumes must depend on XZ distance from the player (ignore Y).
1.11.2.2) Volume must decrease smoothly with distance using a realistic attenuation curve (inverse-square-like is acceptable).
1.11.2.3) At sufficiently large distances, zombie SFX volume must be effectively silent (0).

1.11.3) Performance
1.11.3.1) The implementation must avoid creating an unbounded number of simultaneous looping audio sources.
1.11.3.2) At most 6 zombies may have an active looping `walk.mp3` sound at any time (closest walking zombies only).