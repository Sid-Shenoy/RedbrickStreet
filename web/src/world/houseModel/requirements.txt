1) Lot-local coordinates and transforms (`lotTransform.ts`)

1.1) Lot-local coordinate system

1.1.1) All model geometry is expressed in lot-local coordinates unless explicitly stated otherwise.
1.1.2) Lot-local bounds:
1.1.2.1) localX is within [0, xsize]
1.1.2.2) localZ is within [0, zsize]
1.1.2.3) For this project, zsize must be 30 for all houses

1.1.3) Orientation rule (consistent "front" for both sides of street)
1.1.3.1) The lot-local "front" edge is always localZ = zsize (30), regardless of which side of the street the house is on.
1.1.3.2) The lot-local "back" edge is always localZ = 0.

1.2) Converting lot-local (localX, localZ) to world/street coordinates

1.2.1) Exported function: `lotLocalToWorld(house, localX, localZ) -> { x, z }`
1.2.2) Even-numbered houses:
1.2.2.1) worldX = house.bounds.x + localX
1.2.2.2) worldZ = house.bounds.z + localZ
1.2.3) Odd-numbered houses (mirrored to preserve 1.1.3):
1.2.3.1) worldX = house.bounds.x + (house.bounds.xsize - localX)
1.2.3.2) worldZ = house.bounds.z + (house.bounds.zsize - localZ)

2) House modeling and determinism (`attachHouseModel.ts`, `generateHouseModel.ts`, `generation/context.ts`)

2.1) Attaching house models

2.1.1) Exported function: `attachHouseModel(house, streetSeed) -> HouseWithModel`
2.1.2) `attachHouseModel` must return the input house config plus a `model` attribute.
2.1.3) `model` must be generated by `generateHouseModel(house, streetSeed)`.

2.2) House model generation pipeline

2.2.1) Exported function: `generateHouseModel(house, streetSeed) -> HouseModel`
2.2.2) Generation layers (all must be present):
2.2.2.1) plot
2.2.2.2) firstFloor
2.2.2.3) secondFloor

2.2.3) Preconditions and validation
2.2.3.1) `house.bounds.zsize` must equal 30; otherwise generation must throw an Error.
2.2.3.2) The generator may throw if it cannot satisfy the constraints in this file.

2.3) Determinism contract

2.3.1) Seed string
2.3.1.1) The model seed string must be exactly:
2.3.1.1.1) `${streetSeed}/house/${house.houseNumber}`

2.3.2) Deterministic output requirement
2.3.2.1) For a given tuple:
2.3.2.1.1) streetSeed
2.3.2.1.2) house.houseNumber
2.3.2.1.3) house.bounds (x, z, xsize, zsize)
2.3.2.1.4) house.occupants.length
2.3.2.2) The generated `HouseModel` must be identical across runs.

2.4) Current modeling scope (no objects yet)

2.4.1) Each layer must contain:
2.4.1.1) `regions` (fully generated)
2.4.1.2) `construction` (currently empty)
2.4.1.3) `objects` (currently empty)
2.4.2) Construction items (walls/doors/windows/stairs) and movable objects are out of scope for the current implementation.

2.5) Failure behavior and error format

2.5.1) If constraints cannot be satisfied, generation must fail fast by throwing an Error.
2.5.2) Errors should include a clear prefix indicating which stage failed
2.5.2.1) Must be one of `plot: ...`, `firstFloor: ...`, `secondFloor: ...`
2.5.3) Precondition validation errors thrown before entering a stage (e.g. invalid lot bounds)
2.5.3.1) May omit the stage prefix
2.5.3.2) Must still include the house number, the invalid value, and the expected value (or expected range)

3) House model data format (`types.ts`)

3.1) HouseModel

3.1.1) A HouseModel must contain:
3.1.1.1) `seed: string`
3.1.1.2) `plot: FloorModel`
3.1.1.3) `firstFloor: FloorModel`
3.1.1.4) `secondFloor: FloorModel`

3.2) FloorModel

3.2.1) A FloorModel must contain:
3.2.1.1) `regions: Region[]`
3.2.1.2) `construction: unknown[]` (currently empty)
3.2.1.3) `objects: unknown[]` (currently empty)

3.3) Region surface enum

3.3.1) Each region must have a `surface` in:
3.3.1.1) { black, grass, concrete_light, concrete_medium, concrete_dark, wood_light, wood_medium, wood_dark, tile_light, tile_medium, tile_dark }

3.4) Region geometry format

3.4.1) Each region must have:
3.4.1.1) `name: string` (unique within the same layer)
3.4.1.2) `type: "rectangle" | "polygon"`
3.4.1.3) `points` in lot-local coordinates

3.4.2) Rectangle format
3.4.2.1) points: [[min_x, min_z], [max_x, max_z]]

3.4.3) Polygon format
3.4.3.1) points: [[p1_x, p1_z], [p2_x, p2_z], ... [pn_x, pn_z]]
3.4.3.2) Polygons must not be explicitly closed (do not repeat the first point at the end); closure is implied by consumers.

3.5) Geometry invariants (all layers)

3.5.1) Coordinate bounds
3.5.1.1) All region coordinates must remain within lot-local bounds:
3.5.1.1.1) x in [0, xsize] (allowing tiny floating tolerance)
3.5.1.1.2) z in [0, 30] (allowing tiny floating tolerance)

3.5.2) Shape constraints
3.5.2.1) Region shapes must be axis-aligned rectangles or simple (non-self-intersecting) orthogonal polygons.
3.5.2.2) Polygon edges must be axis-aligned.
3.5.2.3) Polygon point lists should be simplified (no redundant collinear vertices).
3.5.2.4) Polygon boundary order
3.5.2.4.1) Polygon points must be listed in boundary traversal order (clockwise or counter-clockwise).
3.5.2.4.2) The consumer assumes closure between the last point and the first point.
3.5.2.5) No-holes constraint
3.5.2.5.1) Polygons must describe a single outer boundary with no interior holes.
3.5.2.6) Axis-aligned vertex rule (normative)
3.5.2.6.1) Each consecutive pair of polygon vertices must share x or share z (within tolerance).
3.5.2.6.2) Polygons must not contain duplicate consecutive vertices.

3.5.3) Partitioning constraints (within a single layer)
3.5.3.1) Regions in the same layer must not overlap in area.
3.5.3.2) Shared boundaries are allowed.
3.5.3.3) Regions in the same layer must fully cover that layer's footprint.
3.5.3.4) Each region should be a single connected area (no disjoint "islands" for the same region name).

3.6) Definitions for validation (normative)

3.6.1) Overlap definition
3.6.1.1) Two regions overlap if their intersection has non-zero area (shared edges or shared corners do not count as overlap).

3.6.2) Full coverage definition
3.6.2.1) Let footprintArea be the area of the layer footprint.
3.6.2.2) Let unionArea be the area of the union of all regions in the layer.
3.6.2.3) The layer is considered fully covered if:
3.6.2.3.1) abs(unionArea - footprintArea) <= max(0.75, footprintArea * 0.0015)

3.6.3) Shared boundary length definition (for connectivity requirements)
3.6.3.1) Two regions are considered "connected" if they share a boundary segment with length >= 1.0m.
3.6.3.2) Shared boundary length is measured in lot-local meters along the region boundary.

4) Plot layer specification (`generation/plot.ts`)

4.1) This file produces the outdoor plot partition and the building footprint polygon (`houseregion`) used by both floors.

4.2) Exported function
4.2.1) Export: `generatePlotModel(house, ctx) -> FloorModel`
4.2.2) Output:
4.2.2.1) Must return a FloorModel where `construction` and `objects` are empty arrays.
4.2.2.2) Must satisfy all constraints in section 4.

4.2.3) Inputs and dependencies (normative)
4.2.3.1) Plot generation must use:
4.2.3.1.1) `house.bounds` (xsize and fixed zsize=30)
4.2.3.1.2) the deterministic per-house seed in `ctx.seed`
4.2.3.2) Plot generation must produce the `houseregion` footprint polygon used as the exact footprint for both indoor floors.

4.3) Plot footprint and coverage

4.3.1) The plot footprint is the full lot rectangle:
4.3.1.1) x in [0, xsize]
4.3.1.2) z in [0, 30]
4.3.2) The plot regions must form a non-overlapping partition of the plot footprint.

4.4) Plot regions (exact set)

4.4.1) The plot must contain exactly 8 regions, exactly one each with the following names:
4.4.1.1) backyard
4.4.1.2) houseregion
4.4.1.3) frontlawn_near (front lawn area between house front bump and sidewalk)
4.4.1.4) frontlawn_far (lawn strip beyond sidewalk to lot front edge)
4.4.1.5) driveway_near (driveway area between house and sidewalk)
4.4.1.6) driveway_far (driveway area beyond sidewalk to lot front edge)
4.4.1.7) sidewalk
4.4.1.8) walkway (pedestrian path from sidewalk to the house entry edge)

4.4.2) Required plot region types
4.4.2.1) `sidewalk` must be a rectangle.
4.4.2.2) `driveway_near` and `driveway_far` must be rectangles.
4.4.2.3) `walkway` must be a rectangle.
4.4.2.4) `houseregion` must be a polygon (even if it could be represented as a rectangle).
4.4.2.5) All other regions may be rectangles or polygons as long as they remain orthogonal and satisfy coverage/no-overlap.

4.4.3) Required plot surfaces
4.4.3.1) backyard: grass
4.4.3.2) houseregion: black
4.4.3.3) frontlawn_near: grass
4.4.3.4) frontlawn_far: grass
4.4.3.5) driveway_near: concrete_dark
4.4.3.6) driveway_far: concrete_dark
4.4.3.7) sidewalk: concrete_light
4.4.3.8) walkway: concrete_medium

4.5) Sidewalk fixed geometry

4.5.1) Sidewalk width must be 1.5m and must sit 3.5m away from the road edge (measured from the sidewalk edge closest to the road).
4.5.2) In lot-local coordinates, sidewalk must always be the rectangle:
4.5.2.1) from (0, 25) to (xsize, 26.5)

4.6) Deterministic plot variation (allowed variation without prescribing implementation)

4.6.1) Driveway side
4.6.1.1) Driveway side may be left or right.
4.6.1.2) The choice must be deterministic from the house seed.

4.6.2) Driveway width
4.6.2.1) Driveway width must be deterministic and realistic.
4.6.2.2) The driveway must leave a visible lawn strip on the opposite side (non-driveway side).

4.6.3) Walkway width
4.6.3.1) Walkway width must be deterministic and realistic.

4.6.4) House footprint variation
4.6.4.1) House depth and front bump/porch depth must be deterministic and realistic.
4.6.4.2) The house front bump/porch must remain behind the sidewalk (so walkway can connect).

4.6.5) Optional rear extension/notch
4.6.5.1) An optional rear extension/notch may be included deterministically.
4.6.5.2) If present, it must remain orthogonal and must not violate the partitioning and bound constraints.

4.7) Plot connectivity requirements

4.7.1) Walkway must touch sidewalk:
4.7.1.1) `walkway` must be connected to `sidewalk` by shared boundary length >= 1.0m.
4.7.2) Walkway must touch the house entry:
4.7.2.1) `walkway` must be connected to the front edge of `houseregion` by shared boundary length >= 1.0m.
4.7.3) Driveway must touch the house:
4.7.3.1) `driveway_near` must be connected to `houseregion` by shared boundary length >= 1.0m.

5) First floor specification (`generation/firstFloor.ts`)

5.1) Partitions the `houseregion` footprint into ground-floor functional zones suitable for later object placement.

5.2) Exported function

5.2.1) Export: `generateFirstFloorModel(house, ctx, plot) -> FloorModel`
5.2.2) Inputs:
5.2.2.1) `plot` must include a region named `houseregion` (type polygon).
5.2.2.2) `plot` must include `driveway_near` (rectangle) and `walkway` (rectangle).
5.2.3) Output:
5.2.3.1) Must return a FloorModel where `construction` and `objects` are empty arrays.
5.2.3.2) Must satisfy all constraints in section 5.

5.2.4) Inputs and dependencies (normative)
5.2.4.1) First-floor generation must partition exactly the plot `houseregion` polygon footprint
5.2.4.2) First-floor generation must use:
5.2.4.2.1) plot `walkway` to establish the entry/foyer interface requirement
5.2.4.2.2) plot `driveway_near` to establish the garage interface requirement

5.3) First floor footprint and coverage

5.3.1) The first floor footprint is exactly the polygon region in `plot.regions` where name === "houseregion".
5.3.2) First-floor regions must form a non-overlapping partition of the first-floor footprint.

5.4) Required regions (exact set)

5.4.1) The first floor must contain exactly one region each with the following names:
5.4.1.1) foyer (entry region immediately inside the front door; must be the indoor region that interfaces with the plot walkway)
5.4.1.2) garage (vehicle storage/work region; must be the indoor region that interfaces with the plot driveway_near)
5.4.1.3) livingroom (primary lounge/seating region)
5.4.1.4) kitchen (food preparation region)
5.4.1.5) dining (region intended for a dining table; must interface with the kitchen)
5.4.1.6) bathroom_small (small/powder bathroom region)
5.4.1.7) stairs (stair region that will later contain the staircase construction; rectangle-only for downstream use)
5.4.1.8) hallway (circulation region connecting other first-floor rooms)

5.4.2) Required region type constraints
5.4.2.1) `stairs` must be a rectangle region.

5.5) Optional regions (exactly 2)

5.5.1) The first floor must contain exactly 2 distinct optional regions.
5.5.2) `laundry` must always be included.
5.5.3) Exactly one of { pantry, utility } must be included (never both).
5.5.4) The choice of pantry vs utility must be deterministic from the house seed and may depend on available space.

5.6) First floor connectivity constraints

5.6.1) foyer must connect to plot walkway:
5.6.1.1) `foyer` must be connected to plot `walkway` by shared boundary length >= 1.0m.
5.6.2) garage must connect to plot driveway_near:
5.6.2.1) `garage` must be connected to plot `driveway_near` by shared boundary length >= 1.0m.
5.6.3) livingroom must connect to foyer:
5.6.3.1) `livingroom` must be connected to `foyer` by shared boundary length >= 1.0m.
5.6.4) dining must connect to kitchen:
5.6.4.1) `dining` must be connected to `kitchen` by shared boundary length >= 1.0m.

6) Second floor specification (`generation/secondFloor.ts`)

6.1) Partitions the same footprint into upstairs zones, enforcing stairwell congruence and bedroom/closet counts based on occupancy.

6.2) Exported function

6.2.1) Export: `generateSecondFloorModel(house, ctx, plot, firstFloor) -> FloorModel`
6.2.2) Inputs:
6.2.2.1) `plot` must include a region named `houseregion` (type polygon).
6.2.2.2) `firstFloor` must include a region named `stairs` (type rectangle).
6.2.3) Output:
6.2.3.1) Must return a FloorModel where `construction` and `objects` are empty arrays.
6.2.3.2) Must satisfy all constraints in section 6.

6.2.4) Inputs and dependencies (normative)
6.2.4.1) Second-floor generation must partition exactly the plot `houseregion` polygon footprint
6.2.4.2) Second-floor generation must use:
6.2.4.2.1) `firstFloor.regions.stairs` to create the congruent `stairwell` region
6.2.4.2.2) `house.occupants.length` to determine bedroom bounds and choose a deterministic bedroom count

6.3) Second floor footprint and coverage

6.3.1) The second floor footprint is exactly the polygon region in `plot.regions` where name == "houseregion".
6.3.2) Second-floor regions must form a non-overlapping partition of the second-floor footprint.

6.4) Bedroom count constraints

6.4.1) Let occ = house.occupants.length.
6.4.2) Minimum bedrooms = ceil(occ / 2).
6.4.3) Maximum bedrooms = min(3, minimum bedrooms + 1).
6.4.4) The generator must deterministically choose a bedroom count within [minBedrooms, maxBedrooms].
6.4.5) Bedroom regions must be named:
6.4.5.1) bedroom1, bedroom2, bedroom3 (up to the chosen bedroom count)

6.5) Required regions (exact set)

6.5.1) The second floor must contain exactly one region each with the following names:
6.5.1.1) office
6.5.1.2) bathroom_large
6.5.1.3) bathroom_small
6.5.1.4) stairwell
6.5.1.5) hallway

6.5.2) Stairwell congruence requirement
6.5.2.1) `stairwell` must be a rectangle region.
6.5.2.2) `stairwell` must overlap and be congruent with the first floor `stairs` region:
6.5.2.2.1) The stairwell rectangle coordinates must exactly match the first-floor stairs rectangle coordinates (in lot-local space).

6.6) Closet count constraints

6.6.1) The second floor must contain between 1 and 3 closet regions (inclusive).
6.6.2) Closet count must be deterministic.
6.6.3) Closet regions must be named:
6.6.3.1) closet1, closet2, closet3 (up to the chosen closet count)

6.7) Second floor connectivity constraints

6.7.1) hallway must connect to stairwell:
6.7.1.1) `hallway` must be connected to `stairwell` by shared boundary length >= 1.0m.

Example of an input house object (from `web/public/config/houses.json`):
```
{
  "houseNumber": 0,
  "surname": "Whitlock",
  "occupants": [1, 2, 3, 4],
  "bounds": {
    "x": 0,
    "z": 0,
    "xsize": 12,
    "zsize": 30
  }
}
```

Example of an output house object (after being loaded and updated):
(Note: polygons are not explicitly closed in data; closure is implied.)
```
{
  "houseNumber": 0,
  "surname": "Whitlock",
  "occupants": [1, 2, 3, 4],
  "bounds": {
    "x": 0,
    "z": 0,
    "xsize": 12,
    "zsize": 30
  },
  "model": {
    "seed": "redbrick-street/v0/house/0",
    "plot": {
      "regions": [
        {
          "name": "backyard",
          "surface": "grass",
          "type": "polygon",
          "points": [
            [0, 0],
            [12, 0],
            [12, 8.733541874913499 ],
            [6.873786556411067, 8.733541874913499],
            [6.873786556411067, 7.782772364048287],
            [2.6011149613815348, 7.782772364048287],
            [2.6011149613815348, 8.733541874913499],
            [0, 8.733541874913499]
          ]
        },
        {
          "name": "houseregion",
          "surface": "black",
          "type": "polygon",
          "points": [
            /* ... */
          ]
        },
        /* ... */
      ],
      "construction": [],
      "objects": []
    },
    "firstFloor": {
      "regions": [ /* ... */ ],
      "construction": [],
      "objects": []
    },
    "secondFloor": {
      "regions": [ /* ... */ ],
      "construction": [],
      "objects": []
    }
  }
}
```
