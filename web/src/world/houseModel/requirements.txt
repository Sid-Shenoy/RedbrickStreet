1) Lot-local coordinates and transforms (`lotTransform.ts`)

1.1) Lot-local coordinate system

1.1.1) All house-model geometry is expressed in lot-local coordinates unless explicitly stated otherwise.
1.1.2) Lot-local bounds:
1.1.2.1) localX is within [0, xsize]
1.1.2.2) localZ is within [0, zsize]
1.1.2.3) For this project, zsize must be 30 for all houses
1.1.3) Orientation rule (consistent "front" for both sides of street)
1.1.3.1) The lot-local "front" edge is always localZ = zsize (30), regardless of which side of the street the house is on.
1.1.3.2) The lot-local "back" edge is always localZ = 0.

1.2) Converting lot-local (localX, localZ) to world/street coordinates

1.2.1) Exported function: `lotLocalToWorld(house, localX, localZ) -> { x, z }`
1.2.2) Even-numbered houses:
1.2.2.1) worldX = house.bounds.x + localX
1.2.2.2) worldZ = house.bounds.z + localZ
1.2.3) Odd-numbered houses (mirrored to preserve 1.1.3):
1.2.3.1) worldX = house.bounds.x + (house.bounds.xsize - localX)
1.2.3.2) worldZ = house.bounds.z + (house.bounds.zsize - localZ)

2) House modeling and determinism (`attachHouseModel.ts`, `generateHouseModel.ts`, `generation/context.ts`)

2.1) Attaching house models

2.1.1) Exported function: `attachHouseModel(house, streetSeed) -> HouseWithModel`
2.1.2) `attachHouseModel` must return the input house config plus a `model` attribute.
2.1.3) `model` must be generated by `generateHouseModel(house, streetSeed)`.

2.2) House model generation pipeline

2.2.1) Exported function: `generateHouseModel(house, streetSeed) -> HouseModel`
2.2.2) Generation layers (all must be present):
2.2.2.1) plot
2.2.2.2) firstFloor
2.2.2.3) secondFloor
2.2.3) Post-processing stages (must run after rooms are generated):
2.2.3.1) doors (adds Door elements into `firstFloor.construction` and `secondFloor.construction`; `plot.construction` remains empty)

2.3) Preconditions (minimal, pragmatic)

2.3.1) `house.bounds.zsize` must equal 30; otherwise model generation must throw an Error.
2.3.2) Validation may be staged:
2.3.2.1) `makeHouseGenContext` must validate zsize=30.
2.3.2.2) Each generation stage may validate additional inputs it relies on.

2.4) Determinism contract

2.4.1) Seed string
2.4.1.1) The model seed string must be exactly:
2.4.1.1.1) `${streetSeed}/house/${house.houseNumber}`
2.4.2) Deterministic output requirement
2.4.2.1) For a given tuple:
2.4.2.1.1) streetSeed
2.4.2.1.2) house.houseNumber
2.4.2.1.3) house.bounds (x, z, xsize, zsize)
2.4.2.1.4) house.occupants.length
2.4.2.2) The generated `HouseModel` must be identical across runs.

2.5) Current modeling scope (this milestone)

2.5.1) Each layer must contain:
2.5.1.1) `regions` (generated)
2.5.1.2) `construction` (doors only; other construction types later)
2.5.1.3) `objects` (empty for now)
2.5.2) `regions` represent navigable floor/ground surface "zones".
2.5.3) `construction` currently contains only `Door` elements (section 3.6, section 7).
2.5.4) Detailed walls/windows/stairs geometry is out of scope for now and will be added later under `construction`.

2.6) Failure behavior and error format

2.6.1) If constraints cannot be satisfied, generation must fail fast by throwing an Error.
2.6.2) Errors thrown inside a stage should include a clear prefix indicating the stage:
2.6.2.1) `plot: ...`
2.6.2.2) `firstFloor: ...`
2.6.2.3) `secondFloor: ...`
2.6.2.4) `doors: ...`
2.6.3) Precondition validation errors thrown before entering a stage may omit the prefix, but must include:
2.6.3.1) house number
2.6.3.2) the invalid value
2.6.3.3) the expected value (or expected range)

3) House model data format (`types.ts`)

3.1) HouseModel

3.1.1) A HouseModel must contain:
3.1.1.1) `seed: string`
3.1.1.2) `plot: FloorModel`
3.1.1.3) `firstFloor: FloorModel`
3.1.1.4) `secondFloor: FloorModel`

3.2) FloorModel

3.2.1) A FloorModel must contain:
3.2.1.1) `regions: Region[]`
3.2.1.2) `construction: ConstructionElement[]`
3.2.1.3) `objects: unknown[]` (empty for now)

3.3) Region surface enum

3.3.1) Each region must have a `surface` in:
3.3.1.1) { black, brick, grass, concrete_light, concrete_medium, concrete_dark, wood_light, wood_medium, wood_dark, tile_light, tile_medium, tile_dark, void }

3.4) Region geometry format

3.4.1) Each region must have:
3.4.1.1) `name: string` (a semantic label; duplicates are allowed unless a layer explicitly forbids them)
3.4.1.2) `type: "rectangle" | "polygon"`
3.4.1.3) `points` in lot-local coordinates
3.4.2) Rectangle format
3.4.2.1) points: [[min_x, min_z], [max_x, max_z]]
3.4.3) Polygon format
3.4.3.1) points: [[p1_x, p1_z], [p2_x, p2_z], ... [pn_x, pn_z]]
3.4.3.2) Polygons must not be explicitly closed (do not repeat the first point at the end); closure is implied by consumers.
3.4.4) Finding regions by name (important for duplicates)
3.4.4.1) If multiple regions share the same `name`, consumers must treat that name as a category.
3.4.4.2) When a layer requires "a region named X", it means:
3.4.4.2.1) at least one region exists where region.name === X

Example region objects:

Object 1)
```
{
  "name": "garage",
  "surface": "concrete_dark",
  "type": "rectangle",
  "points": [[0, 18.3], [3.4, 22.9]]
}
```

Object 2)
```
{
  "name": "houseregion",
  "surface": "black",
  "type": "polygon",
  "points": [[0, 22.1], [13.6, 22.1], [13.6, 7.2], [0, 7.2]]
}
```

3.5) Geometry invariants (all layers)

3.5.1) Coordinate bounds
3.5.1.1) All region coordinates must remain within lot-local bounds (tiny floating tolerance allowed):
3.5.1.1.1) x in [0, xsize]
3.5.1.1.2) z in [0, 30]
3.5.2) Shape constraints (realistic + generator-friendly)
3.5.2.1) Regions must be axis-aligned rectangles or simple (non-self-intersecting) orthogonal polygons.
3.5.2.2) Polygon edges must be axis-aligned.
3.5.2.3) Polygon point lists should be simplified (no redundant collinear vertices, no duplicate consecutive vertices).
3.5.3) Non-overlap
3.5.3.1) Regions in the same layer must not overlap in area (shared edges/corners are allowed).
3.5.4) Room realism minimums (hard, to avoid "weird rooms")
3.5.4.1) No region may have area < 2.0 m^2.
3.5.4.2) No region may have a minimum bounding-box dimension < 1.0 m.
3.5.4.3) Recommendation: avoid any region edge shorter than 0.8 m.

3.6) Construction elements (doors only for now)

3.6.1) `ConstructionElement` union
3.6.1.1) `construction` must be an array of `ConstructionElement`.
3.6.1.2) For this milestone, the only allowed `ConstructionElement` is `Door`.

3.6.2) Door format (axis-aligned wall opening)

3.6.2.1) A `Door` must have:
3.6.2.1.1) `kind: "door"`
3.6.2.1.2) `aRegion: number` (index into the containing layer's `regions` array)
3.6.2.1.3) `bRegion: number | null`
3.6.2.1.3.1) `bRegion` is the index of the adjacent region across the door (interior door), OR
3.6.2.1.3.2) `bRegion = null` for an exterior door (door opens to outside of the footprint)
3.6.2.1.4) `hinge: [x, z]` (lot-local coordinates, on the wall line)
3.6.2.1.5) `end: [x, z]` (lot-local coordinates, on the same wall line)

3.6.2.2) Door geometry invariants (hard)
3.6.2.2.1) `hinge` and `end` must be on the same axis-aligned wall line:
3.6.2.2.1.1) either `hinge[0] === end[0]` (vertical wall) OR
3.6.2.2.1.2) `hinge[1] === end[1]` (horizontal wall)
3.6.2.2.2) Door width must be exactly 0.8 m (tiny tolerance allowed):
3.6.2.2.2.1) `distance(hinge, end) === 0.8`
3.6.2.2.3) Both points must lie within lot-local bounds (same tolerance rules as regions):
3.6.2.2.3.1) x in [0, xsize]
3.6.2.2.3.2) z in [0, 30]
3.6.2.2.4) For interior doors (`bRegion !== null`), the door segment must lie fully on a boundary segment shared by region `aRegion` and region `bRegion`.
3.6.2.2.5) For exterior doors (`bRegion === null`), the door segment must lie fully on the exterior boundary of region `aRegion` (i.e., on the boundary between the interior footprint and the outside).

Example Door element (interior):
```
{
  "kind": "door",
  "aRegion": 3,
  "bRegion": 4,
  "hinge": [7.0, 12.6],
  "end": [7.8, 12.6]
}
```

Example Door element (exterior):
```
{
  "kind": "door",
  "aRegion": 1,
  "bRegion": null,
  "hinge": [5.2, 22.1],
  "end": [6.0, 22.1]
}
```

4) Plot layer specification (`generation/plot.ts`) (KEEP AS-IS FUNCTIONALLY)

4.1) Intent

4.1.1) Produces:
4.1.1.1) the outdoor plot partition (yard/driveway/sidewalk/etc.)
4.1.1.2) the building footprint polygon (`houseregion`) used as the reference footprint for indoor floors

4.2) Exported function

4.2.1) Export: `generatePlotModel(house, ctx) -> FloorModel`
4.2.2) Output must return a FloorModel where `construction` and `objects` are empty arrays.

4.3) Plot footprint

4.3.1) The plot footprint is the full lot rectangle:
4.3.1.1) x in [0, xsize]
4.3.1.2) z in [0, 30]
4.3.2) The plot regions must form a non-overlapping partition of the plot footprint.

4.4) Required plot regions (exact set)

4.4.1) The plot must contain exactly 9 regions, exactly one each with the following names:
4.4.1.1) backyard
4.4.1.2) houseregion
4.4.1.3) frontlawn_near
4.4.1.4) frontlawn_far
4.4.1.5) driveway_near
4.4.1.6) driveway_far
4.4.1.7) sidewalk
4.4.1.8) curb
4.4.1.9) walkway

4.4.2) Required plot region types
4.4.2.1) `sidewalk` and `curb` must be rectangles.
4.4.2.2) `driveway_near` and `driveway_far` must be rectangles.
4.4.2.3) `walkway` must be a rectangle.
4.4.2.4) `houseregion` must be a polygon.
4.4.3) Required plot surfaces
4.4.3.1) backyard: grass
4.4.3.2) houseregion: black
4.4.3.3) frontlawn_near: grass
4.4.3.4) frontlawn_far: grass
4.4.3.5) driveway_near: concrete_dark
4.4.3.6) driveway_far: concrete_dark
4.4.3.7) sidewalk: concrete_light
4.4.3.8) curb: concrete_light
4.4.3.9) walkway: concrete_medium

4.5) Fixed geometry (must match `plot.ts`)

4.5.1) Sidewalk must always be:
4.5.1.1) rectangle from (0, 25) to (xsize, 26.5)
4.5.2) Curb must always be:
4.5.2.1) rectangle from (0, 29.8) to (xsize, 30)

4.6) Plot realism constraints (must match `plot.ts`)

4.6.1) Driveway width must be within [3.0, 3.8].
4.6.2) Walkway width must be within [1.1, 1.8].
4.6.3) frontGap = 25.0 - frontZ(houseregion) must be within [2.0, 4.5].
4.6.4) The back-most edge of `houseregion` must be at localZ >= 6.0.
4.6.5) `houseregion` must be orthogonal and have minimum area:
4.6.5.1) >= 120.0 m^2 for households needing <= 2 bedrooms
4.6.5.2) >= 135.0 m^2 for households needing 3 bedrooms

5) First floor specification (`generation/firstFloor.ts`) (MORE ROOMS WHEN FEASIBLE, STILL EASY)

5.1) Intent

5.1.1) Produces a believable first-floor layout as a set of non-overlapping zones (rectangles and/or orthogonal polygons)
5.1.2) Must be suitable for navigation and later object placement.
5.1.3) Zones represent walkable floor surfaces, not exact architectural construction.
5.1.4) IMPORTANT: The first floor does NOT need to cover the entire `houseregion` footprint.
5.1.5.1) Uncovered areas represent thickness of exterior walls, built-ins, or other non-walkable parts.

5.2) Exported function

5.2.1) Export: `generateFirstFloorModel(house, ctx, plot) -> FloorModel`
5.2.2) Inputs:
5.2.2.1) `plot` must include a region named `houseregion` (type polygon).
5.2.2.2) `plot` must include `driveway_near` (rectangle) and `walkway` (rectangle).
5.2.3) Output:
5.2.3.1) Must return a FloorModel where `construction` and `objects` are empty arrays.

5.3) Region set

5.3.1) Required regions (must include at least one each):
5.3.1.1) garage          (must be present)
5.3.1.2) foyer
5.3.1.3) hallway
5.3.1.4) livingroom
5.3.1.5) kitchen
5.3.1.6) bathroom_small
5.3.1.7) stairs
5.3.2) Extra rooms (generate if feasible; 0..N allowed)
5.3.2.1) diningroom
5.3.2.2) mudroom
5.3.2.3) pantry
5.3.2.4) laundry
5.3.2.5) office
5.3.2.6) closet
5.3.2.7) storage
5.3.3) "If feasible" means:
5.3.3.1) all required rooms still meet constraints, and
5.3.3.2) the extra room meets its minimum size constraints (5.5.5), and
5.3.3.3) it can be placed without overlap and within `houseregion`

5.4) Placement and realism constraints (hard)

5.4.1) All first-floor regions (rectangles and polygons) must lie fully within the `houseregion` polygon (boundary-touching allowed).
5.4.2) Required exterior interfaces (for believable entry)
5.4.2.1) The `garage` region must touch the front boundary of `houseregion` and align with the plot driveway.
5.4.2.1.1) It must share a boundary segment of length >= 2.5 m with plot `driveway_near` (along the house front edge).
5.4.2.2) The `foyer` region must touch the front boundary of `houseregion` and align with the plot walkway.
5.4.2.2.1) It must share a boundary segment of length >= 0.8 m with plot `walkway` (along the house front edge).
5.4.3) Interior connectivity (simple, hard)
5.4.3.1) `foyer` must share a boundary segment length >= 0.8 m with `hallway` OR `livingroom`.
5.4.3.2) `hallway` must share a boundary segment length >= 0.8 m with `stairs`.
5.4.3.3) `bathroom_small` must share a boundary segment length >= 0.8 m with `hallway`.
5.4.3.4) `kitchen` must share a boundary segment length >= 0.8 m with `livingroom` OR `diningroom` OR `hallway`.
5.4.3.5) `garage` must share a boundary segment length >= 0.8 m with `hallway` OR `mudroom` OR `foyer` (representing an interior door).
5.4.3.6) If present:
5.4.3.6.1) `diningroom` must share a boundary segment length >= 0.8 m with `kitchen` OR `livingroom`.
5.4.3.6.2) `mudroom` must share a boundary segment length >= 0.8 m with `garage` OR `hallway`.
5.4.3.6.3) `pantry` must share a boundary segment length >= 0.8 m with `kitchen`.
5.4.3.6.4) `laundry` should share a boundary segment length >= 0.8 m with `hallway` OR `mudroom`.
5.4.3.6.5) `office` should share a boundary segment length >= 0.8 m with `hallway` OR `livingroom`.
5.4.3.7) Global connectivity (hard)
5.4.3.7.1) Adjacency definition (for connectivity checks)
5.4.3.7.1.1) Two regions A and B are considered "adjacent" if they share a boundary segment of length >= 0.8 m.
5.4.3.7.2) Required-room connectivity
5.4.3.7.2.1) The subgraph formed by the required regions:
5.4.3.7.2.1.1) garage
5.4.3.7.2.1.2) foyer
5.4.3.7.2.1.3) hallway
5.4.3.7.2.1.4) livingroom
5.4.3.7.2.1.5) kitchen
5.4.3.7.2.1.6) bathroom_small
5.4.3.7.2.1.7) stairs
5.4.3.7.2.2) must be a single connected component under the adjacency definition in 5.4.3.7.1.
5.4.4) Room size minimums (hard, realistic)
5.4.4.1) garage: area >= 18.0, minDim >= 3.0
5.4.4.2) livingroom: area >= 16.0, minDim >= 3.2
5.4.4.3) kitchen: area >= 10.0, minDim >= 2.6
5.4.4.4) foyer: area >= 5.0, minDim >= 1.8
5.4.4.5) hallway: area >= 6.0, minDim >= 1.0
5.4.4.6) bathroom_small: area >= 2.6, minDim >= 1.4
5.4.4.7) stairs: area >= 3.6, minDim >= 1.0
5.4.5) Extra room minimums (hard if that room is present)
5.4.5.1) diningroom: area >= 10.0, minDim >= 2.6
5.4.5.2) mudroom: area >= 4.0, minDim >= 1.6
5.4.5.3) pantry: area >= 2.5, minDim >= 1.2
5.4.5.4) laundry: area >= 4.0, minDim >= 1.6
5.4.5.5) office: area >= 8.0, minDim >= 2.4
5.4.5.6) closet: area >= 2.0, minDim >= 1.0
5.4.5.7) storage: area >= 3.0, minDim >= 1.2

5.4.6) Full-coverage partition (hard)
5.4.6.1) The union of all first-floor regions must equal the plot `houseregion` footprint (within tiny floating tolerance).
5.4.6.2) First-floor regions must not overlap in area (shared edges/corners are allowed).
5.4.6.3) The generator may use a mix of rectangle and polygon regions to achieve full coverage.

5.4.7) Robustness and deterministic retries (hard)
5.4.7.1) If a generated layout violates any hard requirement in section 5, `generateFirstFloorModel` must retry with a different deterministic variant rather than failing immediately.
5.4.7.2) The retry process must be deterministic under the house seed contract (2.4).
5.4.7.3) The retry process must stop after a fixed small maximum number of attempts; if still invalid, throw an Error prefixed with `firstFloor: ...`.

5.4.8) Layout variability (hard)
5.4.8.1) Across houses, the first-floor generator must produce meaningfully different partitions (not a single dominant template).
5.4.8.2) Variation may include which extra rooms are included, room shapes (rectangle vs polygon), and relative placement/sizing of required rooms, as long as all hard constraints are satisfied.

5.5) Suggested surfaces (recommended defaults)

5.5.1) garage: concrete_dark
5.5.2) foyer: any wood
5.5.3) hallway: any wood
5.5.4) livingroom: any wood
5.5.5) kitchen: any tile
5.5.6) bathroom_small: any tile
5.5.7) stairs: wood_medium
5.5.8) diningroom: any wood
5.5.9) mudroom: any tile
5.5.10) pantry: any tile
5.5.11) laundry: any tile
5.5.12) office: any wood
5.5.13) closet: any wood
5.5.14) storage: concrete_medium

Example firstFloor output (with a couple extras):
```
{
  "regions": [
    { "name": "garage", "surface": "concrete_dark", "type": "rectangle", "points": [[0.0, 16.0], [3.4, 22.1]] },
    { "name": "mudroom", "surface": "tile_medium", "type": "rectangle", "points": [[0.0, 7.2], [3.4, 16.0]] },
    { "name": "foyer", "surface": "wood_light", "type": "rectangle", "points": [[3.4, 19.1], [7.0, 22.1]] },
    { "name": "hallway", "surface": "wood_light", "type": "rectangle", "points": [[5.7, 7.2], [7.0, 19.1]] },
    { "name": "stairs", "surface": "wood_medium", "type": "rectangle", "points": [[3.4, 15.5], [5.7, 19.1]] },
    { "name": "bathroom_small", "surface": "tile_light", "type": "rectangle", "points": [[3.4, 13.3], [5.7, 15.5]] },
    { "name": "closet", "surface": "wood_light", "type": "rectangle", "points": [[3.4, 7.2], [5.7, 13.3]] },
    { "name": "kitchen", "surface": "tile_medium", "type": "rectangle", "points": [[7.0, 7.2], [10.6, 12.6]] },
    { "name": "diningroom", "surface": "wood_medium", "type": "rectangle", "points": [[10.6, 7.2], [13.6, 12.6]] },
    { "name": "livingroom", "surface": "wood_medium", "type": "rectangle", "points": [[7.0, 12.6], [13.6, 22.1]] }
  ],
  "construction": [],
  "objects": []
}
```

6) Second floor specification (`generation/secondFloor.ts`) (MORE ROOMS WHEN FEASIBLE, NO NUMBERED BEDROOMS)

6.1) Intent

6.1.1) Produces a believable upstairs layout for bedrooms and bathrooms.
6.1.2) Regions represent walkable zones and do not need to perfectly cover the footprint.
6.1.3) The second floor may be smaller than the first floor footprint, as long as it remains believable.

6.2) Exported function

6.2.1) Export: `generateSecondFloorModel(house, ctx, plot, firstFloor) -> FloorModel`
6.2.2) Inputs:
6.2.2.1) `plot` must include a region named `houseregion` (type polygon).
6.2.2.2) `firstFloor` must include at least one region named `stairs` (type rectangle).
6.2.3) Output:
6.2.3.1) Must return a FloorModel where `construction` and `objects` are empty arrays.

6.3) Bedroom count guidance (simple)

6.3.1) Let occ = house.occupants.length.
6.3.2) Recommended minimum bedrooms = ceil(occ / 2).
6.3.3) Recommended maximum bedrooms = min(4, recommended minimum bedrooms + 1).
6.3.4) Each generated bedroom region must have:
6.3.4.1) name exactly `bedroom`
6.3.4.2) (i.e., multiple regions will share the same name)

6.4) Region set

6.4.1) Required regions (must include at least one each):
6.4.1.1) hallway
6.4.1.2) bathroom_large (at least one)
6.4.1.3) bathroom_small (at least one)
6.4.1.4) bedroom (at least one; may be multiple, per 6.3)
6.4.2) Extra rooms (generate if feasible; 0..N allowed)
6.4.2.1) bathroom_small (additional; beyond the required one)
6.4.2.2) closet (may be multiple)
6.4.2.3) laundry
6.4.2.4) office
6.4.2.5) storage (may be multiple)
6.4.3) "If feasible" means:
6.4.3.1) all required rooms still meet constraints, and
6.4.3.2) the extra room meets its minimum size constraints (6.7.2), and
6.4.3.3) it can be placed without overlap and within `houseregion`

6.5) Placement and connectivity (hard)

6.5.1) All second-floor rectangles must lie fully within the `houseregion` polygon (boundary-touching allowed).
6.5.2) Stair arrival
6.5.2.1) `hallway` must touch (share an edge segment with) the projection of a first-floor `stairs` rectangle.
6.5.3) Connectivity
6.5.3.1) Every `bedroom` must share a boundary segment length >= 0.8 m with `hallway`.
6.5.3.2) Every bathroom (bathroom_small/bathroom_large) must share a boundary segment length >= 0.8 m with `hallway`.
6.5.3.3) If present, `closet` should share a boundary segment length >= 0.8 m with a `bedroom` OR share a boundary segment length >= 0.8 m with `hallway`.

6.6) Room size minimums (hard, realistic)

6.6.1) Required-room minimums
6.6.1.1) bedroom (each): area >= 10.0, minDim >= 2.6
6.6.1.2) hallway: area >= 5.0, minDim >= 1.0
6.6.1.3) bathroom_small: area >= 3.2, minDim >= 1.6
6.6.1.4) bathroom_large: area >= 5.0, minDim >= 2.0
6.6.2) Extra-room minimums (hard if that room is present)
6.6.2.1) closet: area >= 2.0, minDim >= 1.0
6.6.2.2) laundry: area >= 4.0, minDim >= 1.6
6.6.2.3) office: area >= 7.0, minDim >= 2.2
6.6.2.4) storage: area >= 3.0, minDim >= 1.2

6.7) Suggested surfaces (recommended defaults)

6.7.1) hallway: any wood
6.7.2) bedroom: any wood
6.7.3) bathroom_small/bathroom_large: any tile
6.7.4) closet: any wood
6.7.5) laundry: any tile
6.7.6) office: any wood
6.7.7) storage: concrete_medium

Example secondFloor output (3 bedrooms, all named "bedroom"):
```
{
  "regions": [
    { "name": "hallway", "surface": "wood_medium", "type": "rectangle", "points": [[5.8, 14.5], [7.6, 20.0]] },
    { "name": "bathroom_large", "surface": "tile_light", "type": "rectangle", "points": [[7.6, 16.0], [10.0, 18.4]] },
    { "name": "bathroom_small", "surface": "tile_medium", "type": "rectangle", "points": [[5.8, 20.0], [7.6, 22.2]] },
    { "name": "bedroom", "surface": "wood_medium", "type": "rectangle", "points": [[7.6, 12.0], [13.0, 16.0]] },
    { "name": "bedroom", "surface": "wood_medium", "type": "rectangle", "points": [[7.6, 18.4], [13.0, 22.2]] },
    { "name": "bedroom", "surface": "wood_medium", "type": "rectangle", "points": [[3.0, 18.4], [5.8, 22.2]] }
  ],
  "construction": [],
  "objects": []
}
```

7) Door generation stage (`generation/doors.ts`) (ADD DOORS INTO `construction`)

7.1) Intent

7.1.1) Add door openings to the already-generated room layouts.
7.1.2) Doors are represented as simple wall segments (hinge->end) suitable for rendering as:
7.1.2.1) a gap in the wall at floor height, plus
7.1.2.2) a standard overhead lintel/opening treatment (not stored in JSON; same for all doors)

7.2) Exported function

7.2.1) Export: `generateDoors(house, ctx, plot, firstFloor, secondFloor) -> { firstFloorDoors: Door[]; secondFloorDoors: Door[] }`
7.2.2) The function must not modify `regions` in any layer.
7.2.3) The returned door arrays must be written into:
7.2.3.1) `firstFloor.construction`
7.2.3.2) `secondFloor.construction`
7.2.3.3) `plot.construction` must remain `[]`

7.3) Determinism

7.3.1) Door generation must be deterministic under the seed contract (2.4).
7.3.2) For the same inputs (house bounds, occupant count, and the generated room regions), door placement must be identical across runs.

7.4) Door placement rules (hard)

7.4.1) All generated doors must satisfy the `Door` format + invariants defined in section 3.6.
7.4.2) Each door must lie fully on an existing axis-aligned boundary segment:
7.4.2.1) interior doors: on a segment shared by exactly two regions (aRegion and bRegion)
7.4.2.2) exterior doors: on a segment on the exterior boundary of the indoor footprint (bRegion = null)
7.4.3) Door width must be exactly 0.8 m (hinge->end length).
7.4.4) Every door must reference regions by index, not by name (to handle duplicate names like `bedroom`).

7.5) Required doors (hard)

7.5.1) First floor doors (minimum set)
7.5.1.1) A front exterior door must exist:
7.5.1.1.1) `aRegion` must be the region containing the entry (`foyer`)
7.5.1.1.2) `bRegion` must be `null`
7.5.1.1.3) the door segment must lie on the front boundary of the indoor footprint and align with the plot `walkway` overlap area
7.5.1.2) For each first-floor connectivity requirement that implies a passage between two regions, exactly one interior door must exist on their shared boundary, including:
7.5.1.2.1) `foyer` with (`hallway` OR `livingroom`) depending on which adjacency exists in the generated layout
7.5.1.2.2) `hallway` with `stairs`
7.5.1.2.3) `hallway` with `bathroom_small`
7.5.1.2.4) `kitchen` with (`livingroom` OR `diningroom` OR `hallway`) depending on which adjacency exists
7.5.1.2.5) `garage` with (`hallway` OR `mudroom` OR `foyer`) depending on which adjacency exists
7.5.1.3) If optional rooms exist and the first-floor spec requires/encourages connectivity for them, door(s) should be generated on the relevant shared boundaries (subject to feasibility).

7.5.2) Second floor doors (minimum set)
7.5.2.1) Every `bedroom` region must have exactly one interior door connecting it to the second-floor `hallway`.
7.5.2.2) Every bathroom region (`bathroom_small`, `bathroom_large`) must have exactly one interior door connecting it to the second-floor `hallway`.
7.5.2.3) If `closet` exists and touches `hallway` or a `bedroom`, generate an interior door on the corresponding shared boundary when feasible.

7.6) Failure behavior

7.6.1) If required doors cannot be placed while satisfying section 3.6 invariants, the stage must fail fast by throwing an Error prefixed with:
7.6.1.1) `doors: ...`
7.6.2) The error message must include:
7.6.2.1) house number
7.6.2.2) which required door could not be placed (e.g. "hallway->bathroom_small")
7.6.2.3) the blocking reason (e.g. "no shared boundary segment >= 0.8m")
